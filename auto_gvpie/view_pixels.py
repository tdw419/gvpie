"""
Pixel Program Viewer
Visualizes pixel programs generated by the LLM
"""

import json
import argparse
import pathlib
from typing import List, Tuple

try:
    from PIL import Image
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False
    print("⚠️  PIL not available, ASCII-only view")

try:
    import lancedb
    LANCEDB_AVAILABLE = True
except ImportError:
    LANCEDB_AVAILABLE = False


REPO_ROOT = pathlib.Path(__file__).parent.parent
ARTIFACTS_DIR = REPO_ROOT / "artifacts"
DB_PATH = str(REPO_ROOT / "lancedb")


class PixelRenderer:
    """Renders pixel programs to images or ASCII"""

    def __init__(self, program: dict):
        self.program = program
        self.canvas = program.get("canvas", {"width": 64, "height": 64})
        self.w = self.canvas["width"]
        self.h = self.canvas["height"]
        self.palette = program.get("palette", {})
        self.pixels = self._init_pixels()

    def _init_pixels(self) -> List[List[Tuple[int, int, int]]]:
        """Initialize black canvas"""
        return [[(0, 0, 0) for _ in range(self.w)] for _ in range(self.h)]

    def _color_of(self, name_or_rgb) -> Tuple[int, int, int]:
        """Resolve color name to RGB tuple"""
        if isinstance(name_or_rgb, list):
            return tuple(name_or_rgb[:3])
        return tuple(self.palette.get(name_or_rgb, [255, 0, 255]))  # magenta if missing

    def render(self):
        """Apply all ops to the canvas"""
        for op in self.program.get("ops", []):
            kind = op.get("op")

            if kind == "FILL":
                c = self._color_of(op["color"])
                for y in range(self.h):
                    for x in range(self.w):
                        self.pixels[y][x] = c

            elif kind == "SET":
                x, y = op.get("x", 0), op.get("y", 0)
                c = self._color_of(op["color"])
                if 0 <= x < self.w and 0 <= y < self.h:
                    self.pixels[y][x] = c

            elif kind == "RECT":
                x = op.get("x", 0)
                y = op.get("y", 0)
                ww = op.get("width", 1)
                hh = op.get("height", 1)
                c = self._color_of(op["color"])
                for yy in range(y, min(y + hh, self.h)):
                    for xx in range(x, min(x + ww, self.w)):
                        if 0 <= xx < self.w and 0 <= yy < self.h:
                            self.pixels[yy][xx] = c

            elif kind == "WRITE_TEXT":
                # For now, just mark the starting position
                x, y = op.get("x", 0), op.get("y", 0)
                c = self._color_of(op.get("color", "fg"))
                text = op.get("text", "")
                for i, char in enumerate(text[:self.w - x]):
                    if 0 <= x + i < self.w and 0 <= y < self.h:
                        self.pixels[y][x + i] = c

    def to_ascii(self) -> str:
        """Convert to ASCII art"""
        chars = {True: "█", False: "·"}
        lines = []
        for row in self.pixels:
            line = "".join(chars[p != (0, 0, 0)] for p in row)
            lines.append(line)
        return "\n".join(lines)

    def to_pil(self, scale: int = 8):
        """Convert to PIL Image"""
        if not PIL_AVAILABLE:
            return None

        img = Image.new("RGB", (self.w, self.h))
        for y in range(self.h):
            for x in range(self.w):
                img.putpixel((x, y), self.pixels[y][x])

        # Upscale for visibility
        if scale > 1:
            img = img.resize((self.w * scale, self.h * scale), Image.NEAREST)

        return img


def load_latest_from_lancedb():
    """Load latest pixel program from LanceDB"""
    if not LANCEDB_AVAILABLE:
        return None

    try:
        db = lancedb.connect(DB_PATH)
        if "artifacts" not in db.table_names():
            return None

        tbl = db.open_table("artifacts")
        rows = list(tbl.search().limit(1))
        return rows[0] if rows else None
    except Exception as e:
        print(f"⚠️  Error loading from LanceDB: {e}")
        return None


def load_from_file(file_path: pathlib.Path):
    """Load pixel program from JSON file"""
    try:
        data = json.loads(file_path.read_text())
        return {
            "id": file_path.stem,
            "program": data
        }
    except Exception as e:
        print(f"⚠️  Error loading {file_path}: {e}")
        return None


def view_program(program_data: dict, output_path: str = None):
    """View a pixel program"""
    prog = program_data.get("program", program_data)

    print(f"{'='*60}")
    print(f"Pixel Program Viewer")
    print(f"{'='*60}\n")

    print(f"ID: {program_data.get('id', 'unknown')}")
    print(f"Name: {prog.get('name', 'unnamed')}")
    print(f"Canvas: {prog['canvas']['width']}×{prog['canvas']['height']}")
    print(f"Version: {prog.get('version', 1)}")

    metadata = prog.get("metadata", {})
    if metadata:
        print(f"Metadata:")
        for k, v in metadata.items():
            print(f"  {k}: {v}")

    print(f"\nPalette:")
    for name, rgb in prog.get("palette", {}).items():
        print(f"  {name}: RGB{tuple(rgb)}")

    print(f"\nOps ({len(prog.get('ops', []))}):")
    for i, op in enumerate(prog.get("ops", []), 1):
        print(f"  {i}. {op['op']}", end="")
        if "x" in op and "y" in op:
            print(f" at ({op['x']},{op['y']})", end="")
        if "color" in op:
            print(f" color={op['color']}", end="")
        if "width" in op:
            print(f" {op['width']}×{op['height']}", end="")
        if "text" in op:
            print(f' text="{op["text"]}"', end="")
        print()

    # Render
    print(f"\n{'='*60}")
    print("Rendering...")
    print(f"{'='*60}\n")

    renderer = PixelRenderer(prog)
    renderer.render()

    # ASCII view
    print("ASCII Preview:")
    print(renderer.to_ascii())

    # Save PNG if possible
    if PIL_AVAILABLE:
        img = renderer.to_pil(scale=8)
        if img:
            if not output_path:
                output_path = f"{program_data.get('id', 'pixel_program')}.png"
            img.save(output_path)
            print(f"\n✅ Saved to: {output_path}")
    else:
        print("\n⚠️  Install PIL to save PNG: pip install pillow")


def main():
    parser = argparse.ArgumentParser(description="View pixel programs")
    parser.add_argument("--latest", action="store_true", help="View latest from LanceDB")
    parser.add_argument("--file", type=str, help="View from JSON file")
    parser.add_argument("--list", action="store_true", help="List all artifacts")
    parser.add_argument("--output", type=str, help="Output PNG path")
    args = parser.parse_args()

    if args.list:
        # List all JSON files in artifacts
        if ARTIFACTS_DIR.exists():
            files = sorted(ARTIFACTS_DIR.glob("*.json"))
            print(f"Found {len(files)} pixel programs:\n")
            for f in files:
                print(f"  {f.name}")
        else:
            print("No artifacts directory found")
        return

    # Load program
    program_data = None

    if args.latest:
        program_data = load_latest_from_lancedb()
        if not program_data:
            print("⚠️  No programs found in LanceDB, trying artifacts directory...")
            # Fallback to latest file
            if ARTIFACTS_DIR.exists():
                files = sorted(ARTIFACTS_DIR.glob("art-*.json"))
                if files:
                    program_data = load_from_file(files[-1])

    elif args.file:
        program_data = load_from_file(pathlib.Path(args.file))

    else:
        # Default: try to find any pixel program
        if ARTIFACTS_DIR.exists():
            files = sorted(ARTIFACTS_DIR.glob("art-*.json"))
            if files:
                program_data = load_from_file(files[-1])
                print(f"Using latest artifact: {files[-1].name}\n")

    if not program_data:
        print("❌ No pixel program found")
        print("\nTry:")
        print("  --latest    View latest from LanceDB")
        print("  --file X    View specific JSON file")
        print("  --list      List all artifacts")
        return

    view_program(program_data, output_path=args.output)


if __name__ == "__main__":
    main()
